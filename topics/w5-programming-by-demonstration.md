# W5 - Programming by Demonstration

### Reading List

#### Required Reading

* [Helena](https://helena-lang.org/): Chasins, S., & Bodik, R. (2017). Skip blocks: reusing execution history to accelerate web scripts. Proceedings of the ACM on Programming Languages, 1(OOPSLA), 1-28.

#### Optional Reading

* [Flashfill](https://support.microsoft.com/en-us/office/using-flash-fill-in-excel-3f9bcf1e-db93-4890-94a0-1578341f73f7): Gulwani, S. (2011). Automating string processing in spreadsheets using input-output examples. ACM Sigplan Notices, 46(1), 317-330.


#### Blog Post (Request Review)

Making an inanimate thing perform actions automatically after demonstrating what you want it to do has been a dream for a very long time. No logic that has to be thoroughly thought out and no knowledge of a programming language, simply demonstrate what you want to get done, and the artificial creation itself figures out what you want from it. As so many things in life, reality is usually disappointing. For a program to understand what you want, you usually need to program each action, define what it needs to do for each edge case and even then it might not work as you want it to. For a program to learn from demonstration adds another layer of complexity on top of it, where it has to for example visually, through a video input, or mechanically, through a movement performed by moving the robot arm, understand what you want and then do the programming itself which then guides the movement later. With the added computation power and layer of programming that needs to be done, it is no wonder that the term "programming by demonstration" has only appeared about 30 to 40 years after the first research which became the basis for artificial intelligence. It is still about 40 years old, quite a bit of progress has already been made and still has a lot more potential for improvement.


The simplest form of programming by demonstration (PbD) is an auto-clicker. A program often used by gamers or people trying to automate a specific task, without doing coding. It records mouse movement, the timing of the clicks and which windows the clicks were performed on. When replaying the clicks, it can add random delays to throw off bot detection software and can start operation at defined times. Although this software "learns" what to do, all it is, is a replay with some noise, no true learning, like we understand it, like generalization of the task and performing similar actions, maybe actions we haven't performed before.


A different example for programming by demonstration is in robotics. There have been several implementations on robot arms, where the PbD part is done by moving the robot arm through the desired motions and program it, when to perform these actions. The robot can accumulate actions and perform each at the desired point in time. This, like the auto clicker, although has to understand the 3d movement, also does not generalize to similar situations.


A programming by demonstration program that a lot of people might be familiar with is the Flash Fill Excel feature.
By performing several actions on subsequent cells, the program observes the editing done and proposes similar edits for subsequent cells, be it based on other cells, a math formula or date and time patterns, just to list some examples. This program fits much more our description of learning, it generalizes what it has seen and can perform similar actions further. 


Another programming by demonstration program is the Rousillon tool, a Helena based browser extension, which also relies on the Ringer library. This Rousillon browser extension is a webscraping tool, which uses Ringer to observe the scraping actions for generation of the first row of data, and generates a low level script which can repeat the performed action. Then it runs the code through a Generalizer, which creates a high level script, which generalizes the performed scraping, creating similar actions to collect more data in the same fashion. The important parts of the script are then demonstrated to the user in a block-like way, in the style of Scratch. This script can then be edited, and then run on the Helena Interpreter to collect the web data. This program, although good on paper, when tested by us, often didn't perform. The whole extension relies on a centralized server, which is used for the Generalizer to better generalize actions, but in tern makes it very slow and completely non private. Very often it doesn't work at all, again because of the server. And even if it works, it is a very inefficient way to gather data, since it relies on the program clicking in the graphical user interface, rather then making direct server requests.
In terms of learning though, just like Flash Fill, it does generalize on the performed actions, and learns the patterns. 


The limits of programming by demonstration haven't been pushed, they aren't even in sight yet. With the recent development boom in the area of artificial intelligence, PbD can defintely benefit from it. Having a houserobot do the chores doesn't seem as far now that many companies have developed robots that already are doing regular tasks, like barista robots and warehouse robots. To make one of these robots perform a new chore, you could, for example, demonstrate the desired chore, and the robot will then be able to replicate that chore. Another avenue can be a creation of an application, where a designer can show prototyped user interfaces and how they should transition, and the PbD program could program the app to look and perform like desired. The future for programming by demonstration is very promising, since the result could be programming of actions, without the need for a programmer. At least this is the dream of many who are not versed in programming, since programming development can take quite a long time, and relies on the communication with the client, on what the client wants in the product. The premise of reaching a point, where no programmer is needed, is that the program has to understand what the client wants, better then a group of trained programmers who are also human. Additionally the assumption is that the client knows what they want and how it should be implemented. Even with the development of ai, we have not reached a point, where the ai can program better then the professionals. What we have reached is that the ai can help professionals write code faster. Combine the ai with task specific heuristics and a professional, and you get that PbD will help developers, like many other tools, develop faster and there lies the true opportunity for programming by demonstration algorithms.